var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var axis=createCommonjsModule(function(t,e){t.exports=function(){var t={},e="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var n=e.length;n--;)t["is"+e[n]]=function(t){return function(e){return r.call(e)===t}}(e[n]);return t}()}),axis_1=axis.isObject,axis_2=axis.isNumber,axis_3=axis.isArray,axis_4=axis.isString;function offsetFromZero(t,e){return e+t*(1&e)>>1}function signedModulo(t,e){return(t%e+e)%e}function compassToNumberDirection(t,e){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(e=e.toLowerCase(),t=t.toUpperCase(),"pointy"===e&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===e&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[e][t]}function ensureXY(t,e){return axis_2(t)||axis_2(e)?axis_2(t)?axis_2(e)||(e=t):t=e:t=e=0,{x:t,y:e}}function _defineProperty(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function _objectSpread(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter(function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),n.forEach(function(e){_defineProperty(t,e,r[e])})}return t}function _objectWithoutPropertiesLoose(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||(i[r]=t[r]);return i}function _objectWithoutProperties(t,e){if(null==t)return{};var r,n,i=_objectWithoutPropertiesLoose(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}function _slicedToArray(t,e){return _arrayWithHoles(t)||_iterableToArrayLimit(t,e)||_nonIterableRest()}function _arrayWithHoles(t){if(Array.isArray(t))return t}function _iterableToArrayLimit(t,e){var r=[],n=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(n=(s=a.next()).done)&&(r.push(s.value),!e||r.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==a.return||a.return()}finally{if(i)throw o}}return r}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function thirdCoordinate(t,e){return-t-e}const DIRECTION_COORDINATES=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],DIAGONAL_DIRECTION_COORDINATES=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],EPSILON={x:1e-6,y:1e-6},sqrt3=Math.sqrt(3);function setFactory(t){let e=t.Hex;return function(){return Object.assign(this,e(...arguments))}}function coordinates(){return{x:this.x,y:this.y}}function cube(){return{q:this.q,r:this.r,s:this.s}}function cubeToCartesian(t){let e,r,n=t.q,i=t.r;return this.isPointy()?(e=n+offsetFromZero(this.offset,i),r=i):(e=n,r=i+offsetFromZero(this.offset,n)),{x:e,y:r}}function cartesianToCubeFactory(t){let e=t.Point;return function(t,r){let n,i,o;var s=e(t,r);return n=s.x,r=s.y,this.isPointy()?(i=n-offsetFromZero(this.offset,r),o=r):(i=n,o=r-offsetFromZero(this.offset,n)),{q:i,r:o,s:-i-o}}}function isPointy(){return"pointy"===this.orientation.toLowerCase()}function isFlat(){return"flat"===this.orientation.toLowerCase()}function oppositeCornerDistance(){return 2*this.size}function oppositeSideDistance(){return sqrt3/2*this.oppositeCornerDistance()}function width(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function height(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function cornersFactory(t){let e=t.Point;return function(){const t=this.width(),r=this.height(),n=this.origin,i=n.x,o=n.y;return this.isPointy()?[e(t-i,.25*r-o),e(t-i,.75*r-o),e(.5*t-i,r-o),e(0-i,.75*r-o),e(0-i,.25*r-o),e(.5*t-i,0-o)]:[e(t-i,.5*r-o),e(.75*t-i,r-o),e(.25*t-i,r-o),e(0-i,.5*r-o),e(.25*t-i,0-o),e(.75*t-i,0-o)]}}function centerFactory(t){let e=t.Point;return function(){const t=this.origin,r=t.x,n=t.y;return e(this.width()/2-r,this.height()/2-n)}}function toPointFactory(t){let e=t.Point;return function(){const t=this.q,r=this.r,n=this.size;let i,o;return this.isPointy()?(i=n*sqrt3*(t+r/2),o=3*n/2*r):(i=3*n/2*t,o=n*sqrt3*(r+t/2)),e(i,o)}}function fromPointFactory(t){let e=t.Point,r=t.Hex;return function(t,n){const i=this.size;let o,s,a;var c=e(t,n).subtract(this.center());return o=c.x,n=c.y,this.isPointy()?(s=(o*sqrt3/3-n/3)/i,a=2*n/3/i):(s=2*o/3/i,a=(-o/3+sqrt3/3*n)/i),r({q:s,r:a,s:-s-a}).round()}}function addFactory(t){let e=t.Hex,r=t.Point;return function(t){const n=r(t),i=n.x,o=n.y;return e(this.x+i,this.y+o,_objectSpread({},this))}}function subtractFactory(t){let e=t.Hex,r=t.Point;return function(t){const n=r(t),i=n.x,o=n.y;return e(this.x-i,this.y-o,_objectSpread({},this))}}function equalsFactory(t){let e=t.Point;return function(t){const r=e(t),n=r.x,i=r.y;return this.x===n&&this.y===i}}function distance(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function roundFactory(t){let e=t.Hex;return function(){let t=this.q,r=this.r,n=this.s,i=Math.round(t),o=Math.round(r),s=Math.round(n);const a=Math.abs(t-i),c=Math.abs(r-o),u=Math.abs(n-s);return a>c&&a>u?i=-o-s:c>u?o=-i-s:s=-i-o,e(_objectSpread({},this,{q:i,r:o,s:s}))}}function lerpFactory(t){let e=t.Hex;return function(t,r){const n=this.q*(1-r)+t.q*r,i=this.r*(1-r)+t.r*r;return e(_objectSpread({},this,{q:n,r:i,s:-n-i}))}}function nudge(){return this.add(EPSILON)}function toString(){return`${this.x},${this.y}`}const staticMethods={thirdCoordinate:thirdCoordinate};function extendHexFactory(t){let e=t.ensureXY,r=t.Point;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=cartesianToCubeFactory({Point:r}),i={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:addFactory({Hex:s,Point:r}),cartesian:coordinates,cartesianToCube:n,center:centerFactory({Point:r}),coordinates:coordinates,corners:cornersFactory({Point:r}),cube:cube,cubeToCartesian:cubeToCartesian,distance:distance,equals:equalsFactory({Point:r}),fromPoint:fromPointFactory({Point:r,Hex:s}),height:height,isFlat:isFlat,isPointy:isPointy,lerp:lerpFactory({Hex:s}),nudge:nudge,oppositeCornerDistance:oppositeCornerDistance,oppositeSideDistance:oppositeSideDistance,round:roundFactory({Hex:s}),set:setFactory({Hex:s}),subtract:subtractFactory({Hex:s,Point:r}),toCartesian:cubeToCartesian,toCube:n,toPoint:toPointFactory({Point:r}),toString:toString,width:width},o=Object.assign(i,t);function s(t,r){let n,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(axis_1(t)){let e=t.q,a=t.r,c=t.s,u=_objectWithoutProperties(t,["q","r","s"]);if(axis_2(e)||axis_2(a)||axis_2(c)){if(e+a+c!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${e}, r: ${a}, s: ${c}, sum: ${e+a+c}.`);var s=o.cubeToCartesian({q:e,r:a,s:c});n=s.x,r=s.y}else n=t.x,r=t.y;i=u}else if(axis_3(t)){var a=_slicedToArray(t,2);n=a[0],r=a[1],i={}}else n=t;return Object.assign(Object.create(o),Object.assign(i,e(n,r)))}return o.origin=r(o.origin),Object.assign(s,staticMethods),s}}function pointToHexFactory(t){let e=t.Hex;return function(t,r){return e().fromPoint(t,r)}}function parallelogramFactory(t){let e=t.Grid,r=t.Hex;return function(t){let n=t.width,i=t.height,o=t.start,s=t.direction,a=void 0===s?1:s,c=t.onCreate,u=void 0===c?()=>{}:c;o=r(o);const l=_slicedToArray({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[a],3),f=l[0],h=l[1],d=l[2],y=new e;for(let t=0;t<n;t++)for(let e=0;e<i;e++){const n=r(o.cubeToCartesian({[f]:t+o[f],[h]:e+o[h],[d]:-t-e+o[d]}));u(n,y),y.push(n)}return y}}function triangleFactory(t){let e=t.Grid,r=t.Hex;return function(t){let n=t.size,i=t.start,o=t.direction,s=void 0===o?1:o,a=t.onCreate,c=void 0===a?()=>{}:a;i=r(i);const u={1:{rStart:()=>0,rEnd:t=>n-t},5:{rStart:t=>n-t,rEnd:()=>n+1}}[s],l=u.rStart,f=u.rEnd,h=new e;for(let t=0;t<n;t++)for(let e=l(t);e<f(t);e++){const n=r(i.cubeToCartesian({q:t+i.q,r:e+i.r,s:-t-e+i.s}));c(n,h),h.push(n)}return h}}function hexagonFactory(t){let e=t.Grid,r=t.Hex;return function(t){let n=t.radius,i=t.center,o=t.onCreate,s=void 0===o?()=>{}:o;i=r(i);const a=new e;for(let t=-n;t<=n;t++){const e=Math.max(-n,-t-n),o=Math.min(n,-t+n);for(let n=e;n<=o;n++){const e=r(i.cubeToCartesian({q:t+i.q,r:n+i.r,s:-t-n+i.s}));s(e,a),a.push(e)}}return a}}function rectangleFactory(t){let e=t.Grid,r=t.Hex,n=t.compassToNumberDirection,i=t.signedModulo;return function(t){let o=t.width,s=t.height,a=t.start,c=t.direction,u=void 0===c?r().isPointy()?0:1:c,l=t.onCreate,f=void 0===l?()=>{}:l;a=r(a),axis_4(u)&&(u=n(u,a.orientation)),(u<0||u>5)&&(u=i(u,6));const h=_slicedToArray([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][u],3),d=h[0],y=h[1],x=h[2],p=_slicedToArray(a.isPointy()?[o,s]:[s,o],2),b=p[0],g=p[1],m=new e;for(let t=0;t<g;t++){const e=offsetFromZero(a.offset,t);for(let n=-e;n<b-e;n++){const e=r(a.cubeToCartesian({[d]:n+a[d],[y]:t+a[y],[x]:-n-t+a[x]}));f(e,m),m.push(e)}}return m}}function get(t){return axis_2(t)?this[t]:this[this.indexOf(t)]}function setFactory$1(t){let e=t.isValidHex;return function(t,r){if(!e(r))return this;const n=axis_2(t)?t:this.indexOf(t);return n<0?this.push(r):this[n]=r,this}}function hexesBetween(t,e){const r=t.distance(e),n=1/Math.max(r,1);let i=[];for(let o=0;o<=r;o++){const r=t.nudge().lerp(e.nudge(),n*o).round();i.push(this.get(r))}return i}function hexesInRangeFactory(t){let e=t.isValidHex;return function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!e(t))throw new Error(`Invalid center hex: ${t}.`);if(!this.get(t))throw new Error(`Center hex with coordinates ${t} not present in grid.`);let i=[];for(let e=-r;e<=r;e++)for(let o=Math.max(-r,-e-r);o<=Math.min(r,-e+r);o++){const r=this.get(t.cubeToCartesian({q:t.q+e,r:t.r+o}));t.equals(r)&&!n||i.push(r)}return i.filter(Boolean)}}function neighborsOfFactory(t){let e=t.isValidHex,r=t.signedModulo,n=t.compassToNumberDirection;return function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all",o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e(t))throw new Error(`Invalid hex: ${t}.`);const s=o?DIAGONAL_DIRECTION_COORDINATES:DIRECTION_COORDINATES;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(e=>{axis_4(e)&&(e=n(e,t.orientation)),(e<0||e>5)&&(e=r(e,6));const i=s[e],o=i.q,a=i.r;return this.get(t.cubeToCartesian({q:t.q+o,r:t.r+a}))}).filter(Boolean)}}function defineGridFactory(t){let e=t.extendHex,r=t.Grid,n=t.Point;const i=r.isValidHex;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e();function o(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];return axis_3(t)?n=t:n.unshift(t),new r(...n.filter(i))}return Object.assign(o,{Hex:t,isValidHex:i,pointToHex:pointToHexFactory({Point:n,Hex:t}),parallelogram:parallelogramFactory({Grid:r,Hex:t}),triangle:triangleFactory({Grid:r,Hex:t}),hexagon:hexagonFactory({Grid:r,Hex:t}),rectangle:rectangleFactory({Grid:r,Hex:t,compassToNumberDirection:compassToNumberDirection,signedModulo:signedModulo})}),Object.assign(r.prototype,{get:get,hexesBetween:hexesBetween,hexesInRange:hexesInRangeFactory({isValidHex:i}),neighborsOf:neighborsOfFactory({isValidHex:i,signedModulo:signedModulo,compassToNumberDirection:compassToNumberDirection}),set:setFactory$1({isValidHex:i})}),o}}function addFactory$1(t){let e=t.Point;return function(t,r){let n;var i=e(t,r);return n=i.x,r=i.y,e(this.x+n,this.y+r)}}function subtractFactory$1(t){let e=t.Point;return function(t,r){let n;var i=e(t,r);return n=i.x,r=i.y,e(this.x-n,this.y-r)}}function multiplyFactory(t){let e=t.Point;return function(t,r){let n;var i=e(t,r);return n=i.x,r=i.y,e(this.x*n,this.y*r)}}function divideFactory(t){let e=t.Point;return function(t,r){let n;var i=e(t,r);return n=i.x,r=i.y,e(this.x/n,this.y/r)}}function PointFactory(t){let e=t.ensureXY;const r={add:addFactory$1({Point:n}),subtract:subtractFactory$1({Point:n}),multiply:multiplyFactory({Point:n}),divide:divideFactory({Point:n})};function n(t,n){let i;return i=axis_2(t)?e(t,n):axis_3(t)?e(...t):axis_1(t)?e(t.x,t.y):e(0),Object.assign(Object.create(r),i)}return n}const Point=PointFactory({ensureXY:ensureXY});class Grid extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return!!(this.indexOf(t,e)+1)}indexOf(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=this.length;let n=Number(e);for(t=Point(t),n=Math.max(n>=0?n:r+n,0);n<r;n++)if(this[n].equals(t))return n;return-1}lastIndexOf(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length-1;const r=this.length;let n=Number(e);for(t=Point(t),n=n>=0?Math.min(n,r-1):r+n;n>=0;n--)if(this[n].equals(t))return n;return-1}push(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return super.push(...e.filter(Grid.isValidHex))}splice(t,e){if(null==e)return super.splice(t);for(var r=arguments.length,n=new Array(r>2?r-2:0),i=2;i<r;i++)n[i-2]=arguments[i];return super.splice(t,e,...n.filter(Grid.isValidHex))}unshift(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return super.unshift(...e.filter(Grid.isValidHex))}}const Point$1=PointFactory({ensureXY:ensureXY}),extendHex=extendHexFactory({ensureXY:ensureXY,Point:Point$1}),defineGrid=defineGridFactory({extendHex:extendHex,Grid:Grid,Point:Point$1});export{extendHex,defineGrid,Point$1 as Point};
//# sourceMappingURL=honeycomb.esm.min.js.map
