{"version":3,"file":"honeycomb.esm.min.js","sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/statics.js","../src/hex/constants.js","../src/hex/prototype.js","../src/hex/index.js","../src/grid/statics.js","../src/grid/prototype.js","../src/grid/index.js","../src/point/prototype.js","../src/point/index.js","../src/grid/class.js","../src/honeycomb.js"],"sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n    return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n    return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n    if (!/^(N|S)?(E|W)?$/i.test(value)) {\n        throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n    }\n\n    orientation = orientation.toLowerCase()\n    value = value.toUpperCase()\n\n    if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n    }\n    if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n    }\n\n    /**\n     * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n     * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n     * and flat hexes don't have a west and east compass direction.\n     *\n     * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n     * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n     *\n     * @typedef {string} COMPASS_DIRECTION\n     *\n     * @readonly\n     * @enum {COMPASS_DIRECTION}\n     *\n     * @property {COMPASS_DIRECTION} E  â†’ east\n     * @property {COMPASS_DIRECTION} SE â†˜ southeast\n     * @property {COMPASS_DIRECTION} S  â†“ south\n     * @property {COMPASS_DIRECTION} SW â†™ southwest\n     * @property {COMPASS_DIRECTION} W  â† west\n     * @property {COMPASS_DIRECTION} NW â†– northwest\n     * @property {COMPASS_DIRECTION} N  â†‘ north\n     * @property {COMPASS_DIRECTION} NE â†— northeast\n     */\n    return {\n        pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n        flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 }\n    }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n    if (!isNumber(x) && !isNumber(y)) {\n        x = y = 0\n    } else if (!isNumber(x)) {\n        x = y\n    } else if (!isNumber(y)) {\n        y = x\n    }\n\n    return { x, y }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n    return -firstCoordinate - secondCoordinate\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n    { q: 1, r: 0 },\n    { q: 0, r: 1 },\n    { q: -1, r: 1 },\n    { q: -1, r: 0 },\n    { q: 0, r: -1 },\n    { q: 1, r: -1 }\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n    { q: 2, r: -1 },\n    { q: 1, r: 1 },\n    { q: -1, r: 2 },\n    { q: -2, r: 1 },\n    { q: -1, r: -1 },\n    { q: 1, r: -2 }\n]\n\nexport const EPSILON = { x: 1e-6, y: 1e-6 }\n","import { EPSILON } from './constants'\nimport { offsetFromZero } from '../utils'\n\nconst sqrt3 = Math.sqrt(3)\n\nexport function setFactory({ Hex }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n     * @returns {hex}           Itself with the passed parameters merged into it.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n     * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n     * hex === updatedHex                                   // true: hex is updated in-place\n     */\n    return function set(...args) {\n        return Object.assign(this, Hex(...args))\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n    return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n    return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n    let x, y\n\n    if (this.isPointy()) {\n        x = q + offsetFromZero(this.offset, r)\n        y = r\n    } else {\n        x = q\n        y = r + offsetFromZero(this.offset, q)\n    }\n\n    return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     *\n     * @todo make this a static (and instance?) method\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * const Point = Honeycomb.Point\n     *\n     * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n     */\n    return function cartesianToCube(pointOrX, y) {\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y))\n\n        if (this.isPointy()) {\n            q = x - offsetFromZero(this.offset, y)\n            r = y\n        } else {\n            q = x\n            r = y - offsetFromZero(this.offset, x)\n        }\n\n        return { q, r, s: -q - r }\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy â¬¢ orientation.\n */\nexport function isPointy() {\n    return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat â¬£ orientation.\n */\nexport function isFlat() {\n    return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite corners of a hex.\n */\nexport function oppositeCornerDistance() {\n    return this.size * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite sides of a hex.\n */\nexport function oppositeSideDistance() {\n    return sqrt3 / 2 * this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n    return this.isPointy() ?\n        this.oppositeSideDistance() :\n        this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n    return this.isPointy() ?\n        this.oppositeCornerDistance() :\n        this.oppositeSideDistance()\n}\n\nexport function cornersFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point[]}\n     * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n     * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n     *\n     * @example\n     * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n     * const Hex1 = Honeycomb.extendHex({ size: 30 })\n     * Hex1().corners() // [\n     *                  //    { x: 51.96152422706631, y: 15 },\n     *                  //    { x: 51.96152422706631, y: 45 },\n     *                  //    { x: 25.980762113533157, y: 60 },\n     *                  //    { x: 0, y: 45 },\n     *                  //    { x: 0, y: 15 },\n     *                  //    { x: 25.980762113533157, y: 0 }\n     *                  // ]\n     *\n     * // set the origin to a hex's center\n     * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n     * Hex2().corners() // [\n     *                  //    { x: 25.980762113533157, y: -15 },\n     *                  //    { x: 25.980762113533157, y: 15 },\n     *                  //    { x: 0, y: 30 },\n     *                  //    { x: -25.980762113533157, y: 15 },\n     *                  //    { x: -25.980762113533157, y: -15 },\n     *                  //    { x: 0, y: -30 }\n     *                  // ]\n     */\n    return function corners() {\n        const width = this.width()\n        const height = this.height()\n        const { x, y } = this.origin\n\n        if (this.isPointy()) {\n            return [\n                Point(width - x, height * 0.25 - y),\n                Point(width - x, height * 0.75 - y),\n                Point(width * 0.5 - x, height - y),\n                Point(0 - x, height * 0.75 - y),\n                Point(0 - x, height * 0.25 - y),\n                Point(width * 0.5 - x, 0 - y)\n            ]\n        } else {\n            return [\n                Point(width - x, height * 0.5 - y),\n                Point(width * 0.75 - x, height - y),\n                Point(width * 0.25 - x, height - y),\n                Point(0 - x, height * 0.5 - y),\n                Point(width * 0.25 - x, 0 - y),\n                Point(width * 0.75 - x, 0 - y)\n            ]\n        }\n    }\n}\n\nexport function centerFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n     * Note that the default origin is the top left corner, so the default center is\n     * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n     *\n     * @example\n     * const Hex1 = Honeycomb.extendHex({ size: 10 })\n     * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n     *\n     * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n     * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n     */\n    return function center() {\n        const { x, y } = this.origin\n        return Point(this.width() / 2 - x, this.height() / 2 - y)\n    }\n}\n\nexport function toPointFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} The hex's origin point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 30 })\n     * Hex().toPoint()          // { x: 0, y: 0 }\n     * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n     */\n    return function toPoint() {\n        const { q, r, size } = this\n        let x, y\n\n        if (this.isPointy()) {\n            x = size * sqrt3 * (q + r / 2)\n            y = size * 3/2 * r\n        } else {\n            x = size * 3/2 * q\n            y = size * sqrt3 * (r + q / 2)\n        }\n\n        return Point(x, y)\n    }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n    /**\n     * Returns a hex from the passed {@link point}.\n     *\n     * @memberof Hex\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Point = Honeycomb.Point\n     * const hex = Hex()\n     *\n     * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n     * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n     * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function fromPoint(pointOrX, y) {\n        const { size } = this\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n        if (this.isPointy()) {\n            q = (x * sqrt3 / 3 - y / 3) / size\n            r = y * 2 / 3 / size\n        } else {\n            q = x * 2 / 3 / size\n            r = (-x / 3 + sqrt3 / 3 * y) / size\n        }\n\n        return Hex({ q, r, s: -q - r }).round()\n    }\n}\n\nexport function addFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to add.\n     *\n     * @param {point} point The hex (or point) that will be added to the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n     *                      Any custom properties are copied.\n     */\n    return function add(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x + x, this.y + y, {...this})\n    }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to subtract.\n     *\n     * @param {point} point The hex (or point) that will be subtracted from the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n     *                      Any custom properties are copied.\n     */\n    return function subtract(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x - x, this.y - y, {...this})\n    }\n}\n\nexport function equalsFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n     * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n     */\n    return function equals(point) {\n        const { x, y } = Point(point)\n        return this.x === x && this.y === y\n    }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n    return Math.max(\n        Math.abs(this.q - hex.q),\n        Math.abs(this.r - hex.r),\n        Math.abs(this.s - hex.s)\n    )\n}\n\nexport function roundFactory({ Hex }) {\n    /**\n     * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n     *\n     * @memberof Hex#\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n     *\n     * @returns {hex}   A *new* hex with rounded coordinates.\n     *                  Any custom properties are copied.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n     */\n    return function round() {\n        let { q, r, s } = this\n        let roundedQ = Math.round(q)\n        let roundedR = Math.round(r)\n        let roundedS = Math.round(s)\n        const diffQ = Math.abs(q - roundedQ)\n        const diffR = Math.abs(r - roundedR)\n        const diffS = Math.abs(s - roundedS)\n\n        if (diffQ > diffR && diffQ > diffS) {\n            roundedQ = -roundedR - roundedS\n        } else if (diffR > diffS) {\n            roundedR = -roundedQ - roundedS\n        } else {\n            roundedS = -roundedQ - roundedR\n        }\n\n        return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n    }\n}\n\nexport function lerpFactory({ Hex }) {\n    /**\n     * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n     * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n     *\n     * @memberof Hex#\n     *\n     * @param   {hex} hex   The other hex (cannot be a {@link point}).\n     * @param   {number} t  A \"parameter\" between 0 and 1.\n     *\n     * @returns {hex}       A new hex (likely with floating point coordinates).\n     *                      Any custom properties are copied.\n     */\n    return function lerp(hex, t) {\n        const q = this.q * (1 - t) + hex.q * t\n        const r = this.r * (1 - t) + hex.r * t\n        return Hex({ ...this, q, r, s: -q - r })\n    }\n}\n\n/**\n * @memberof Hex#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n *                  Useful for interpolating in a consistent direction.\n */\nexport function nudge() {\n    return this.add(EPSILON)\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n    return `${this.x},${this.y}`\n}\n","import { isObject, isNumber, isArray } from 'axis.js'\n\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport const staticMethods = {\n    thirdCoordinate: statics.thirdCoordinate\n}\n\nexport default function extendHexFactory({ ensureXY, Point }) {\n    /**\n     * @function extendHex\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create custom hexes by extending the default Hex prototype.\n     *\n     * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n     * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n     *\n     * @todo validate orientation, size, origin\n     * @todo warn when properties are overriden\n     *\n     * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n     *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n     *\n     * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({\n     *     size: 50,\n     *     orientation: 'flat',\n     *     customProperty: `I'm custom ðŸ˜ƒ`,\n     *     customMethod() {\n     *         return `${this.customProperty} and called from a custom method ðŸ˜Ž`\n     *     }\n     * })\n     * const hex = Hex(5, -1)\n     *\n     * hex.coordinates()    // { x: 5, y: -1 }\n     * hex.size             // 50\n     * hex.customProperty   // I'm custom ðŸ˜ƒ\n     * hex.customMethod()   // I'm custom ðŸ˜ƒ and called from a custom method ðŸ˜Ž\n     *\n     * // every hex created with Hex() shares these properties:\n     * const hex2 = Hex(3, 0)\n     * hex2.size            // 50\n     * hex2.customProperty  // I'm custom ðŸ˜ƒ\n     *\n     * // to set properties on individual hexes, pass them to Hex():\n     * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake ðŸ˜Œ` })\n     * hex3.instanceProperty    // I'm a unique snowflake ðŸ˜Œ\n     */\n    return function extendHex(prototype = {}) {\n        const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n        const defaultPrototype = {\n            /**\n             * Used internally for type checking\n             *\n             * @memberof Hex#\n             * @private\n             */\n            __isHoneycombHex: true,\n            /**\n             * Either â¬¢ pointy or â¬£ flat. Defaults to `pointy`.\n             *\n             * @memberof Hex#\n             * @type {string}\n             * @default 'pointy'\n             */\n            orientation: 'pointy',\n            /**\n             * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n             * Can be anything the {@link Honeycomb.Point} factory accepts.\n             * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n             *\n             * @memberof Hex#\n             * @type {point}\n             * @default 0\n             */\n            origin: 0,\n            /**\n             * A hex's radius or the length of any of its sides. Defaults to `1`.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default 1\n             */\n            size: 1,\n            /**\n             * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n             * Defaults to `-1` (odd offset).\n             * See {@link OFFSET} for details.\n             * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default -1\n             * @see OFFSET\n             */\n            offset: -1,\n            /**\n             * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get q() { return this.cartesianToCube(this).q },\n            /**\n             * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get r() { return this.cartesianToCube(this).r },\n            /**\n             * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get s() { return this.cartesianToCube(this).s },\n\n            // methods:\n            add: methods.addFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#coordinates}.\n             * @memberof Hex#\n             * @instance\n             */\n            cartesian: methods.coordinates,\n            cartesianToCube,\n            center: methods.centerFactory({ Point }),\n            coordinates: methods.coordinates,\n            corners: methods.cornersFactory({ Point }),\n            cube: methods.cube,\n            cubeToCartesian: methods.cubeToCartesian,\n            distance: methods.distance,\n            equals: methods.equalsFactory({ Point }),\n            fromPoint: methods.fromPointFactory({ Point, Hex }),\n            height: methods.height,\n            isFlat: methods.isFlat,\n            isPointy: methods.isPointy,\n            lerp: methods.lerpFactory({ Hex }),\n            nudge: methods.nudge,\n            oppositeCornerDistance: methods.oppositeCornerDistance,\n            oppositeSideDistance: methods.oppositeSideDistance,\n            round: methods.roundFactory({ Hex }),\n            set: methods.setFactory({ Hex }),\n            subtract: methods.subtractFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#cubeToCartesian}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCartesian: methods.cubeToCartesian,\n            /**\n             * Alias for {@link Hex#cartesianToCube}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCube: cartesianToCube,\n            toPoint: methods.toPointFactory({ Point }),\n            toString: methods.toString,\n            width: methods.width\n        }\n        const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n        // ensure origin is a point\n        finalPrototype.origin = Point(finalPrototype.origin)\n\n        Object.assign(Hex, staticMethods)\n\n        /**\n         * @function Hex\n         *\n         * @description\n         * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n         *\n         * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n         *\n         * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n         *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n         *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n         *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n         * @param {number} [xOrProps.x=]                    The x coordinate.\n         * @param {number} [xOrProps.y=]                    The y coordinate.\n         * @param {number} [y=]                             The y coordinate.\n         * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n         *\n         * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n         *\n         * @example\n         * const Hex = Honeycomb.extendHex()\n         *\n         * // passing numbers:\n         * Hex()                        // { x: 0, y: 0 }\n         * Hex(1)                       // { x: 1, y: 1 }\n         * Hex(1, 2)                    // { x: 1, y: 2 }\n         *\n         * // passing an object with cartesian coordinates:\n         * Hex({})                      // { x: 0, y: 0 }\n         * Hex({ x: 1 })                // { x: 1, y: 1 }\n         * Hex({ y: 2 })                // { x: 2, y: 2 }\n         * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n         *\n         * // passing an object with cube coordinates:\n         * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n         * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n         *\n         * // passing an array:\n         * Hex([])                      // { x: 0, y: 0 }\n         * Hex([1])                     // { x: 1, y: 1 }\n         * Hex([1, 2])                  // { x: 1, y: 2 }\n         *\n         * // custom properties:\n         * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n         * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n         *\n         * // cloning a hex:\n         * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n         * const clone = Hex(someHex)   // { x: 4, y: -2 }\n         * someHex === clone            // false\n         */\n        function Hex(xOrProps, y, customProps = {}) {\n            let x\n\n            if (isObject(xOrProps)) {\n                let { q, r, s, ...rest } = xOrProps\n\n                if (isNumber(q) || isNumber(r) || isNumber(s)) {\n                    if (q + r + s !== 0) {\n                        throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n                    }\n\n                    ({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n                } else {\n                    ({ x, y } = xOrProps)\n                }\n\n                customProps = rest\n            } else if (isArray(xOrProps)) {\n                [x, y] = xOrProps\n                // ignore all arguments except xOrProps\n                customProps = {}\n            } else {\n                x = xOrProps\n            }\n\n            /**\n             * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n             *\n             * @typedef {Object} hex\n             * @property {number} x Cartesian x coordinate.\n             * @property {number} y Cartesian y coordinate.\n             */\n            return Object.assign(\n                // the prototype has to be attached here, else Grid's shape methods break ðŸ™\n                Object.create(finalPrototype),\n                Object.assign(customProps, ensureXY(x, y))\n            )\n        }\n\n        return Hex\n    }\n}\n","import { isString } from 'axis.js'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n    /**\n     * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link Hex#fromPoint}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const Point = Honeycomb.Point\n     *\n     * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n     * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n     * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function pointToHex(pointOrX, y) {\n        return Hex().fromPoint(pointOrX, y)\n    }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) â–±.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n     */\n    return function parallelogram({\n        width,\n        height,\n        start,\n        direction = 1,\n        /**\n         * Callback of a {@link Grid} shape method.\n         * Gets called for each hex that's about to be added to the grid.\n         *\n         * @callback onCreate\n         * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n         * @param {grid} grid   The grid (for as far as it's created).\n         * @returns {void}      Nothing.\n         */\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: ['q', 'r', 's'],\n            3: ['r', 's', 'q'],\n            5: ['s', 'q', 'r']\n        }\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let first = 0; first < width; first++) {\n            for (let second = 0; second < height; second++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) â–³.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.size                 The side length (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n     * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a triangle arrangement.\n     */\n    return function triangle({\n        size,\n        start,\n        direction = 1,\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: {\n                rStart: () => 0,\n                rEnd: q => size - q\n            },\n            5: {\n                rStart: q => size - q,\n                rEnd: () => size + 1\n            }\n        }\n        const { rStart, rEnd } = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let q = 0; q < size; q++) {\n            for (let r = rStart(q); r < rEnd(q); r++) {\n                const hex = Hex(start.cubeToCartesian({\n                    q: q + start.q,\n                    r: r + start.r,\n                    s: -q - r + start.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) â¬¡.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n     * @param {hex} [options.center=Hex(0)]         The center hex.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n     */\n    return function hexagon({\n        radius,\n        center,\n        onCreate = () => { }\n    }) {\n        center = Hex(center)\n\n        const grid = new Grid()\n\n        for (let q = -radius; q <= radius; q++) {\n            const startR = Math.max(-radius, -q - radius)\n            const endR = Math.min(radius, -q + radius)\n\n            for (let r = startR; r <= endR; r++) {\n                const hex = Hex(center.cubeToCartesian({\n                    q: q + center.q,\n                    r: r + center.r,\n                    s: -q - r + center.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n    /**\n     * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) â–­.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n     * The direction (from the start hex) in which to create the shape.\n     * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n     * Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n     */\n    return function rectangle({\n        width,\n        height,\n        start,\n        direction = Hex().isPointy() ? 0 : 1, // E or S\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n\n        if (isString(direction)) {\n            direction = compassToNumberDirection(direction, start.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n            direction = signedModulo(direction, 6)\n        }\n\n        const DIRECTIONS = [\n            ['q', 'r', 's'],\n            ['r', 'q', 's'],\n            ['r', 's', 'q'],\n            ['s', 'r', 'q'],\n            ['s', 'q', 'r'],\n            ['q', 's', 'r']\n        ]\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n        const grid = new Grid()\n\n        for (let second = 0; second < secondStop; second++) {\n            const secondOffset = offsetFromZero(start.offset, second)\n\n            for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n","import { isString, isNumber } from 'axis.js'\n\nimport { DIRECTION_COORDINATES, DIAGONAL_DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n    if (isNumber(keyOrPoint)) {\n        return this[keyOrPoint]\n    } else {\n        return this[this.indexOf(keyOrPoint)]\n    }\n}\n\nexport function setFactory({ isValidHex }) {\n    /**\n     * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n     *\n     * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n     * If the new hex is invalid, nothing changes.\n     *\n     * @memberof Grid#\n     * @instance\n     *\n     * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n     * @param {hex} newHex                  The replacing hex.\n     *\n     * @returns {grid}                      Itself.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n     *\n     * // replace a hex:\n     * grid.set(0, Hex(1, 1))\n     * grid                         // [ { x: 1, y: 1 } ]\n     * // the target hex can also be a point:\n     * grid.set([1, 1], Hex(2, 2))\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // invalid replace values are ignored:\n     * grid.set(0, 'invalid')\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // when the target hex isn't present in the grid, the replacing hex is added instead:\n     * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n     * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n     */\n    return function set(keyOrPoint, newHex) {\n        if (!isValidHex(newHex)) {\n            return this\n        }\n\n        const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n        if (index < 0) {\n            this.push(newHex)\n        } else {\n            this[index] = newHex\n        }\n\n        return this\n    }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n    const distance = firstHex.distance(lastHex)\n    const step = 1.0 / Math.max(distance, 1)\n    let hexes = []\n\n    for (let i = 0; i <= distance; i++) {\n        const hex = firstHex.nudge().lerp(lastHex.nudge(), step * i).round()\n        hexes.push(this.get(hex))\n    }\n\n    return hexes\n}\n\nexport function hexesInRangeFactory({ isValidHex }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#range-coordinate|redblobgames.com}\n     *\n     * @param {hex} centerHex                   A hex to get surrounding hexes from.\n     * @param {number} [range=0]                The range (in hexes) surrounding the center hex.\n     * @param {boolean} [includeCenterHex=true] Whether to include the center hex in the result\n     *\n     * @returns {hex[]}             An array with all hexes surrounding the passed center hex.\n     *                              Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const grid = Grid.rectangle({ width: 5, height: 5 })\n     *\n     * grid.hexesInRange(Hex(2, 2), 2)          // [\n     *                                          //    { x: 0, y: 2 },\n     *                                          //    { x: 0, y: 3 },\n     *                                          //    { x: 1, y: 4 },\n     *                                          //    ...\n     *                                          //    { x: 3, y: 0 },\n     *                                          //    { x: 3, y: 1 },\n     *                                          //    { x: 4, y: 2 }\n     *                                          // ]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.hexesInRange(Hex(0, 0), 1)          // [\n     *                                          //    { x: 0, y: 0 },\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: 1, y: 0 }\n     *                                          // ]\n     *\n     * // exclude center hex:\n     * grid.hexesInRange(Hex(2, 2), 1, false)   // [\n     *                                          //    { x: 1, y: 2 },\n     *                                          //    { x: 1, y: 3 },\n     *                                          //    { x: 1, y: 1 },\n     *                                          //    { x: 2, y: 3 },\n     *                                          //    { x: 3, y: 2 }\n     *                                          // ]\n     */\n    return function hexesInRange(centerHex, range = 0, includeCenterHex = true) {\n        if (!isValidHex(centerHex)) {\n            throw new Error(`Invalid center hex: ${centerHex}.`)\n        }\n\n        if (!this.get(centerHex)) {\n            throw new Error(`Center hex with coordinates ${centerHex} not present in grid.`)\n        }\n\n        let hexes = []\n\n        for (let q = -range; q <= range; q++) {\n            for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {\n                const hex = this.get(centerHex.cubeToCartesian({ q: centerHex.q + q, r: centerHex.r + r }))\n\n                if (centerHex.equals(hex) && !includeCenterHex) {\n                    continue\n                }\n\n                hexes.push(hex)\n            }\n        }\n\n        return hexes.filter(Boolean)\n    }\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n     *\n     * @param {hex} hex\n     * A hex to get 1 or more neighbors from.\n     * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n     * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n     * @param {boolean} [diagonal=false]\n     * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n     *\n     * @returns {hex[]}\n     * An array of 0 up to 6 neighboring hexes. Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     * @throws {Error} When the direction is invalid for the hex.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n     * const grid = Grid.hexagon({ radius: 1 })\n     *\n     * // all neighbors:\n     * grid.neighborsOf(Hex())          // [\n     *                                  //    { x: 1, y: 0 },\n     *                                  //    { x: 0, y: 1 },\n     *                                  //    { x: -1, y: 1 },\n     *                                  //    { x: -1, y: 0 },\n     *                                  //    { x: -1, y: -1 },\n     *                                  //    { x: 0, y: -1 },\n     *                                  // ]\n     * // specific neighbor:\n     * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n     * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n     *\n     * // multiple neighbors:\n     * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     *\n     * grid.neighborsOf(Hex(), [1, 2])          // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     * // diagonal neighbor:\n     * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.neighborsOf(Hex(-1, -1), 'NW')      // []\n     */\n    return function neighborsOf(hex, directions = 'all', diagonal = false) {\n        if (!isValidHex(hex)) {\n            throw new Error(`Invalid hex: ${hex}.`)\n        }\n\n        const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n        if (directions === 'all') {\n            directions = [0, 1, 2, 3, 4, 5]\n        }\n\n        return directions = []\n            // ensure directions is an array\n            .concat(directions)\n            .map(direction => {\n                // todo: move this to a util, also grid/statics.js#277\n                if (isString(direction)) {\n                    direction = compassToNumberDirection(direction, hex.orientation)\n                }\n\n                if (direction < 0 || direction > 5) {\n                    direction = signedModulo(direction, 6)\n                }\n\n                const { q, r } = coordinates[direction]\n                return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n            })\n            .filter(Boolean)\n    }\n}\n","import { isArray } from 'axis.js'\n\nimport { signedModulo, compassToNumberDirection } from '../utils'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n    const { isValidHex } = Grid\n\n    /**\n     * @function defineGrid\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n     *\n     * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n     *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n     *\n     * @returns {Grid}                          A Grid factory.\n     *\n     * @example\n     * // create a Grid factory that uses the default Hex Factory:\n     * const Grid = Honeycomb.defineGrid()\n     * const hex = Grid.Hex()\n     * hex.size     // 1\n     *\n     * // create your own Hex factory\n     * const CustomHex = Honeycomb.extendHex({ size: 10, custom: 'ðŸ¤“' })\n     * // â€¦and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n     * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n     * const customHex = CustomGrid.Hex()\n     * hex.size     // 10\n     * hex.custom   // ðŸ¤“\n     */\n    return function defineGrid(Hex = extendHex()) {\n        // static properties\n        Object.assign(GridFactory, {\n            /**\n             * The {@link Hex} factory the Grid factory was created with.\n             * @memberof Grid\n             * @static\n             * @function\n             */\n            // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n            // it could cause this:\n            // function methodThatBindsThis() {\n            //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n            // }\n            // which is caused by the following line:\n            Hex,\n\n            // methods\n            /**\n             * @memberof Grid\n             * @static\n             * @method\n             *\n             * @param {*} value     Any value.\n             * @returns {boolean}   Whether the passed value is a valid hex.\n             */\n            isValidHex,\n            pointToHex: statics.pointToHexFactory({ Point, Hex }),\n            parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n            triangle: statics.triangleFactory({ Grid, Hex }),\n            hexagon: statics.hexagonFactory({ Grid, Hex }),\n            rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo })\n        })\n\n        // prototype properties\n        Object.assign(\n            Grid.prototype,\n            {\n                // methods\n                get: methods.get,\n                hexesBetween: methods.hexesBetween,\n                hexesInRange: methods.hexesInRangeFactory({ isValidHex }),\n                neighborsOf: methods.neighborsOfFactory({\n                    isValidHex,\n                    signedModulo,\n                    compassToNumberDirection\n                }),\n                set: methods.setFactory({ isValidHex })\n            }\n        )\n\n        /**\n         * @function Grid\n         *\n         * @description\n         * A function to create hex {@link grid}s and perform various operations on them.\n         *\n         * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n         * It can also be called with 1 or more hexes or an array of hexes to construct/clone a {@link grid} containing those hexes.\n         *\n         * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n         *\n         * @param {(hex[]|hex)} [arrayOrHex]    An array or a hex. Any invalid hexes are filtered out.\n         * @param {...hex} [hexes]              More hexes. Any invalid hexes are filtered out.\n         *\n         * @returns {grid}                      A grid instance containing only valid hexes.\n         *\n         * @example\n         * const Grid = Honeycomb.defineGrid()\n         * // the Hex factory used by the Grid to produce hexes is available as a property\n         * const Hex = Grid.Hex\n         *\n         * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         *\n         * // invalid hexes are filtered out:\n         * Grid('no hex', { x: 3, y: -1 })  // []\n         * Grid(['no hex', Hex(1, -1)])     // [{ x: 1, y: -1 }]\n         *\n         * // clone a grid:\n         * const grid = Grid(Hex(), Hex(1), Hex(2))\n         * const clonedGrid = Grid(grid)    // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n         * grid === clonedGrid              // false\n         */\n        function GridFactory(arrayOrHex, ...hexes) {\n            if (isArray(arrayOrHex)) {\n                hexes = arrayOrHex\n            } else {\n                hexes.unshift(arrayOrHex)\n            }\n\n            /**\n             * @typedef {Object} grid\n             * @extends Array\n             *\n             * @property {number} length    Amount of hexes in the grid.\n             */\n            return new Grid(...hexes.filter(isValidHex))\n        }\n\n        return GridFactory\n    }\n}\n","export function addFactory({ Point }) {\n    /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n    return function add(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x + x, this.y + y)\n    }\n}\n\nexport function subtractFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The difference between the passed point's coordinates and the current point's.\n     */\n    return function subtract(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x - x, this.y - y)\n    }\n}\n\nexport function multiplyFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n     */\n    return function multiply(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x * x, this.y * y)\n    }\n}\n\nexport function divideFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The division of the current point's coordinates and the passed point's.\n     */\n    return function divide(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x / x, this.y / y)\n    }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n    const prototype = {\n        add: methods.addFactory({ Point }),\n        subtract: methods.subtractFactory({ Point }),\n        multiply: methods.multiplyFactory({ Point }),\n        divide: methods.divideFactory({ Point })\n    }\n\n    /**\n     * Factory function for creating two-dimensional points.\n     *\n     * @function Point\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}                             A point.\n     *\n     * @example\n     * const Point = Honeycomb.Point\n     *\n     * Point()                  // { x: 0, y: 0 }\n     * Point(1)                 // { x: 1, y: 1 }\n     * Point(1, 2)              // { x: 1, y: 2 }\n     *\n     * Point([])                // { x: 0, y: 0 }\n     * Point([1])               // { x: 1, y: 1 }\n     * Point([1, 2])            // { x: 1, y: 2 }\n     *\n     * Point({})                // { x: 0, y: 0 }\n     * Point({ x: 1 })          // { x: 1, y: 1 }\n     * Point({ y: 2 })          // { x: 2, y: 2 }\n     * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n     */\n    function Point(pointOrX, y) {\n        let coordinates\n        /**\n         * An object with just an `x` and a `y` property.\n         *\n         * Create your own:\n         * ```javascript\n         * const point = { x: 1, y: 2 }\n         * ```\n         *\n         * Or use the included {@link Point} factory:\n         * ```javascript\n         * const point = Honeycomb.Point(1, 2)\n         * ```\n         *\n         * @typedef {Object} point\n         * @property {number} x (horizontal) x coordinate\n         * @property {number} y (vertical) y coordinate\n         */\n\n        if (isNumber(pointOrX)) {\n            coordinates = ensureXY(pointOrX, y)\n        } else if (isArray(pointOrX)) {\n            coordinates = ensureXY(...pointOrX)\n        } else if (isObject(pointOrX)) {\n            coordinates = ensureXY(pointOrX.x, pointOrX.y)\n        } else {\n            coordinates = ensureXY(0)\n        }\n\n        return Object.assign(\n            Object.create(prototype),\n            coordinates\n        )\n    }\n\n    return Point\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n    /**\n     * @private\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    static isValidHex(value) {\n        return (value || {}).__isHoneycombHex === true\n    }\n\n    /**\n     * @memberof Grid#\n     * @override\n     * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n     *\n     * @returns {TypeError} An error.\n     */\n    fill() {\n        throw new TypeError('Grid.prototype.fill is not implemented')\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n     * but searches the passed hex (which can also be a {@link point}.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *\n     * @returns {boolean}               Whether the hex is included in the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n     *\n     * grid.includes(Hex(0))        // true\n     * grid.includes([0, 0])        // true\n     * grid.includes(Hex(0), 1)     // false\n     * grid.includes(Hex(5, 7))     // false\n     */\n    includes(point, fromIndex = 0) {\n        return !!(this.indexOf(point, fromIndex) + 1)\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *                                  If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.indexOf(Hex(0))     // 0\n     * grid.indexOf([0, 0])     // 0\n     * grid.indexOf(Hex(0), 1)  // 2\n     * grid.indexOf(Hex(5, 7))  // -1\n     */\n    indexOf(point, fromIndex = 0) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = Math.max(i >= 0 ? i : length + i, 0)\n\n        for (i; i < length; i++) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n     * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point                 The coordinates to search for.\n     * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n     *                                      If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.lastIndexOf(Hex(0))     // 2\n     * grid.lastIndexOf([0, 0])     // 2\n     * grid.lastIndexOf(Hex(0), 1)  // 0\n     * grid.lastIndexOf(Hex(5, 7))  // -1\n     */\n    lastIndexOf(point, fromIndex = this.length - 1) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n        for (i; i >= 0; i--) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.push(Hex(1))            // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.push('invalid')         // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     */\n    push(...hexes) {\n        return super.push(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {number} start                        Index at which to start changing the grid.\n     * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n     * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n     *\n     * @returns {hex[]}                             A grid with the deleted hexes (if any).\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid.rectangle({ width: 2, height: 1 })\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 0, y: 1 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     *\n     * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n     *\n     * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n     * grid\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 2, y: 2 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     */\n    splice(start, deleteCount, ...hexes) {\n        // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n        // this is not according to spec: it should delete all hexes (starting from `start`)\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        if (deleteCount == null) {\n            return super.splice(start)\n        }\n\n        return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.unshift(Hex(1))         // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     *\n     * grid.unshift('invalid')      // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     */\n    unshift(...hexes) {\n        return super.unshift(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat|Array#concat}.\n     * @memberof Grid#\n     * @method concat\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin|Array#copyWithin}.\n     * @memberof Grid#\n     * @method copyWithin\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries|Array#entries}.\n     * @memberof Grid#\n     * @method entries\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|Array#every}.\n     * @memberof Grid#\n     * @method every\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|Array#filter}.\n     * @memberof Grid#\n     * @method filter\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|Array#find}.\n     * @memberof Grid#\n     * @method find\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex|Array#findIndex}.\n     * @memberof Grid#\n     * @method findIndex\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|Array#forEach}.\n     * @memberof Grid#\n     * @method forEach\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join|Array#join}.\n     * @memberof Grid#\n     * @method join\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys|Array#keys}.\n     * @memberof Grid#\n     * @method keys\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|Array#map}.\n     * @memberof Grid#\n     * @method map\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop|Array#pop}.\n     * @memberof Grid#\n     * @method pop\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|Array#reduce}.\n     * @memberof Grid#\n     * @method reduce\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight|Array#reduceRight}.\n     * @memberof Grid#\n     * @method reduceRight\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse|Array#reverse}.\n     * @memberof Grid#\n     * @method reverse\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift|Array#shift}.\n     * @memberof Grid#\n     * @method shift\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|Array#some}.\n     * @memberof Grid#\n     * @method some\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort|Array#sort}.\n     * @memberof Grid#\n     * @method sort\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString|Array#toLocaleString}.\n     * @memberof Grid#\n     * @method toLocaleString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString|Array#toString}.\n     * @memberof Grid#\n     * @method toString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values|Array#values}.\n     * @memberof Grid#\n     * @method values\n     * @instance\n     */\n}\n","import { ensureXY } from './utils'\nimport extendHexFactory from './hex'\nimport defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport PointFactory from './point'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport {\n    extendHex,\n    defineGrid,\n    Point\n}\n"],"names":["module","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","factory","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","pointy","E","SE","SW","W","NW","NE","flat","S","N","ensureXY","x","y","isNumber","thirdCoordinate","firstCoordinate","secondCoordinate","DIRECTION_COORDINATES","q","r","DIAGONAL_DIRECTION_COORDINATES","EPSILON","sqrt3","Math","sqrt","setFactory","Hex","assign","coordinates","cube","s","cubeToCartesian","isPointy","cartesianToCubeFactory","Point","pointOrX","isFlat","oppositeCornerDistance","size","oppositeSideDistance","width","height","cornersFactory","origin","centerFactory","toPointFactory","fromPointFactory","subtract","center","round","addFactory","point","subtractFactory","equalsFactory","hex","max","abs","roundFactory","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","lerpFactory","t","nudge","add","staticMethods","statics","extendHexFactory","cartesianToCube","methods","defaultPrototype","__isHoneycombHex","cartesian","corners","equals","fromPoint","lerp","set","toCartesian","toCube","toPoint","finalPrototype","xOrProps","customProps","isObject","rest","isArray","create","pointToHexFactory","parallelogramFactory","Grid","start","direction","onCreate","grid","first","second","push","triangleFactory","rStart","rEnd","hexagonFactory","radius","startR","endR","min","rectangleFactory","isString","firstStop","secondStop","secondOffset","get","keyOrPoint","indexOf","isValidHex","newHex","index","hexesBetween","firstHex","lastHex","step","hexes","hexesInRangeFactory","centerHex","range","includeCenterHex","filter","Boolean","neighborsOfFactory","directions","diagonal","concat","map","defineGridFactory","extendHex","GridFactory","arrayOrHex","unshift","pointToHex","parallelogram","triangle","hexagon","rectangle","hexesInRange","neighborsOf","multiplyFactory","divideFactory","PointFactory","multiply","divide","Array","fill","TypeError","fromIndex","Number","lastIndexOf","super","splice","deleteCount","defineGrid"],"mappings":"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"}